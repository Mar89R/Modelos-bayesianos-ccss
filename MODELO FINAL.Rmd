---
title: "MODELO BAYESIANO FINAL"
Autora: "Margarita Rojas Pérez"
output: html_document
date: "2025-10-09"
editor_options: 
  chunk_output_type: console
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r}
library(reshape2)
library(car)
library(sf)
library(spdep)
library(tidyr)
library(dplyr)
library(writexl)
library(readr)
library(ggplot2)
library(INLA)
library(tmap)
library(tidyverse)
library(gganimate)
library(shiny)
library(leaflet)
library(RColorBrewer)
library(MASS)     
library(AER)
library(corrplot)
library(flextable)
```


#Cargar archivo con los polígonos 
```{r}
#extraer shapefile
shp <- st_read("C:/Users/mrojaspe/OneDrive - Caja Costarricense de Seguro Social/Escritorio/MARGARITA/HE/MODELO/areas_salud/areas_salud.shp")

```


## Crear grafo con los polígonos de adyacencia, necesarios para INLA
```{r}
nb <- poly2nb(shp)

w <- nb2listw(nb, style = "W", zero.policy=TRUE) ##La w normaliza, se recomienda

nb2INLA("adjacency.graph", nb) #archivo de adyacencia 

inla_graph <- inla.read.graph ( filename = "adjacency.graph") ##GRAFO DE ADYACENCIA QUE NECESITAINLA 
```
##baseFinal es el nombre de la base con todas las variables 
##Revisar correlación temporal de las variables 
```{r}
acf(baseFinal$Cobertura, main = "Autocorrelación temporal de Cobertura")
acf(baseFinal$no_control, main = "Autocorrelación temporal de No control")
acf(baseFinal$obsesidad, main = "Autocorrelación temporal de Obesidad")
acf(baseFinal$PobRural, main = "Autocorrelación temporal de Población Rural")


```


###I de Moran con permutaciones es recomendable para modelos poisson, esto para revisar si hay correlación espacial de la variable de interés
```{r}


resultados_moran_mc <- list()
anios <- 2019:2024
vars_interes <- c("egresos_total", "tasa_obs")

for (anio in anios) {
  base_año <- baseFinal %>% filter(Año == anio)
  shp_año <- left_join(shp, base_año, by = "UP")

  for (var in vars_interes) {
    variable <- as.numeric(shp_año[[var]])
    
    # Moran con 999 permutaciones para varaibles poisson 
    moran_mc_res <- moran.mc(variable, w, nsim = 999, zero.policy = TRUE)
    
    resultados_moran_mc[[paste(anio, var, sep = "_")]] <- list(
      Año = anio,
      Variable = var,
      I = moran_mc_res$statistic,
      p_value = moran_mc_res$p.value
    )
  }
}

moran_mc_df <- do.call(rbind, lapply(resultados_moran_mc, as.data.frame))
print(moran_mc_df)

```



```{r}
# Estandarizar variables para que estén en una misma escala
baseFinal <- baseFinal %>%
  mutate(nocontrol_s = scale(no_control, center = TRUE, scale = TRUE)[,1],
         cobertura_s = scale(Cobertura, center = TRUE, scale = TRUE)[,1],
         sobeP_s = scale(Sobrepeso, center = TRUE, scale = TRUE)[,1],
         Obe_s = scale(obsesidad, center = TRUE, scale = TRUE)[,1],
         te_s = scale(te,center = TRUE, scale = TRUE)[,1],
         PobR_s = scale(PobRural,center = TRUE, scale = TRUE)[,1],
         IDS_s = scale(IDS,center = TRUE, scale = TRUE)[,1],
         hta_s = scale(hta,center = TRUE, scale = TRUE)[,1],
         acce_s = scale(acceso,center = TRUE, scale = TRUE)[,1],
         RM_s = scale(RM,center = TRUE, scale = TRUE)[,1],
         Adlt_s = scale(`%65+`,center = TRUE, scale = TRUE)[,1],
         eba_s = scale(ebais,center = TRUE, scale = TRUE)[,1]
         
         )
```



#Matrix de correlación entre variables 

```{r}


# 1. Calcular la matriz de correlación
cor_matrix <- cor(baseFinal[, c("nocontrol_s", "cobertura_s", "sobeP_s", "Obe_s", "te_s", "PobR_s", "IDS_s",  "hta_s", "acce_s", "RM_s", "Adlt_s", "eba_s", "egresos_total")],
                  use = "complete.obs")

# 2. Convertir a formato largo para ggplot
cor_melt <- melt(cor_matrix)

# 3. Graficar heatmap en ggplot 
ggplot(cor_melt, aes(x = Var1, y = Var2, fill = value)) +
  geom_tile(color = "white") +
  scale_fill_gradient2(low = "blue", high = "red", mid = "white", 
                       midpoint = 0, limit = c(-1,1), name = "Correlación") +
  geom_text(aes(label = round(value, 2)), color = "black", size = 4) +
  theme_minimal() +
  theme(axis.text.x = element_text(angle = 45, vjust = 1, hjust=1)) +
  labs(title = "Matriz de Correlaciones",
       x = "", y = "")

```

####Asociación entre las variables 
```{r}

# vector de las variables necesarias 
covariables <- c( "no_control", "Cobertura", "Sobrepeso", "obsesidad","PobRural", "IDS","hta", "RM", "%65+")

# Crear un formato largo con pivot_longer para graficarlas en un solo panel
baseFinal %>%
  pivot_longer(cols = all_of(covariables),
               names_to = "Covariable",
               values_to = "Valor") %>%
  ggplot(aes(x = Valor, y = egresos_total)) +
  geom_point(alpha = 0.5) +
  geom_smooth(method = "lm", color = "blue") +
  facet_wrap(~ Covariable, scales = "free_x") +
  labs(title = "Relación entre egresos y covariables",
       x = "Valor de la covariable",
       y = "Egresos totales") +
  theme_minimal()

```



#####CICLO PARA COMPARAR DIFERENTES COMBINACIONES DE COVARAIBLES DEL MODELO####
```{r}
# =====================================
# Fórmula en INLA PARA USAR EN EL MODELO 
# =====================================
formula_base <- egresos_total ~ 1 +
  f(area_id, replicate = time_id, model = "bym2", graph = inla_graph,
    scale.model = TRUE, constr = TRUE,
    hyper = list(
      phi = list(prior = "pc", param = c(0.5, 0.75)), ##priori de mezcla estructural y no estructural del componente espacial
      prec = list(prior = "pc.prec", param = c(0.5, 0.01)) #priori de presisción de área
    )) +
  f(time_id, model = "ar1")

# =====================================
# Fórmulas con covariables individuales
# =====================================
formula_nocontrol <- update(formula_base, . ~ . + nocontrol_s)
formula_cobertura <- update(formula_base, . ~ . + cobertura_s)
formula_sobeP     <- update(formula_base, . ~ . + sobeP_s)
formula_Obe       <- update(formula_base, . ~ . + Obe_s)
formula_te        <- update(formula_base, . ~ . + te_s)
formula_PobR      <- update(formula_base, . ~ . + PobR_s)
formula_IDS       <- update(formula_base, . ~ . + IDS_s)
formula_hta       <- update(formula_base, . ~ . + hta_s)
formula_acce      <- update(formula_base, . ~ . + acce_s)
formula_RM        <- update(formula_base, . ~ . + RM_s)
formula_Adlt      <- update(formula_base, . ~ . + Adlt_s)
formula_eba       <- update(formula_base, . ~ . + eba_s)

# =====================================
# Modelo con todas las variables
# =====================================
formula_full <- update(formula_base, . ~ . +
  nocontrol_s + cobertura_s + sobeP_s + Obe_s + te_s +
  PobR_s + IDS_s + hta_s + acce_s + RM_s + Adlt_s + eba_s)

# =====================================
# Función para ajustar modelo Poisson
# =====================================
ajustar_mod <- function(formula){
  inla(formula,
       family = "poisson",
       data = baseFinal,
       E = baseFinal$esperados,
       control.fixed = list(correlation.matrix = TRUE, prec.intercept = 1, prec = 1), #priori para efectos fijos y el intercepto
       control.compute = list(dic = TRUE, waic = TRUE, cpo = TRUE))
}

# =====================================
# Modelos (base + individuales + completo)
# =====================================
res <- list(
  pois_base = ajustar_mod(formula_base),
  pois_nc   = ajustar_mod(formula_nocontrol),
  pois_cb   = ajustar_mod(formula_cobertura),
  pois_sobe = ajustar_mod(formula_sobeP),
  pois_obe  = ajustar_mod(formula_Obe),
  pois_te   = ajustar_mod(formula_te),
  pois_PobR = ajustar_mod(formula_PobR),
  pois_IDS  = ajustar_mod(formula_IDS),
  pois_hta  = ajustar_mod(formula_hta),
  pois_acce = ajustar_mod(formula_acce),
  pois_RM   = ajustar_mod(formula_RM),
  pois_Adlt = ajustar_mod(formula_Adlt),
  pois_eba  = ajustar_mod(formula_eba),
  pois_full = ajustar_mod(formula_full)
)

# =====================================
# Comparación de modelos
# =====================================
comp <- lapply(res, function(m){
  c(DIC = m$dic$dic,
    WAIC = m$waic$waic,
    sumNegLogCPO = -sum(log(m$cpo$cpo), na.rm = TRUE))
})
comp <- do.call(rbind, comp)
round(comp, 2)

```

###MODELO FINAL CON COVARIABLES ELEGIDAS###
```{r}

formula <- egresos_total ~ 1 + PobR_s + nocontrol_s +  Obe_s + cobertura_s +
  f(area_id, replicate = time_id, model = "bym2", graph = inla_graph,
    scale.model = TRUE, constr = TRUE,
    hyper = list(
      phi = list(prior = "pc", param = c(0.5, 0.75)), #se espera que la mitad o menos de la variación provenga del efecto estructurado con 75% de probabilidad.
      prec = list(prior = "pc.prec", param = c(0.5, 0.01)) #el modelo penaliza fuertemente efectos temporales con desviaciones estándar mayores que 0.5
    )) +
  f(time_id, model = "ar1")
  
  
  mod_final <- inla(formula,
                  family = "poisson",
                  data = baseFinal,
                  E = baseFinal$esperados,
                  control.fixed = list(correlation.matrix = TRUE, prec.intercept = 1, prec = 1),
       control.compute = list(dic = TRUE, waic = TRUE, cpo = TRUE))
   
```

```{r}

##Revisar criterios de ajuste 
comp_final <- c(
  DIC = mod_final$dic$dic,
  WAIC = mod_final$waic$waic,
  sumNegLogCPO = -sum(log(mod_final$cpo$cpo), na.rm = TRUE)
)


round(comp_final, 2)
```

###Extraer las distribuciones a posterior de los parámetros 
```{r}
# Extraer la distribución posterior de phi
phi_logit <- mod_final$internal.marginals.hyperpar[["Logit phi for area_id"]]

# Transformar de escala logit a escala original (0 a 1)
phi_marginal <- inla.tmarginal(function(x) 1 / (1 + exp(-x)), phi_logit)

# Graficar la distribución posterior de phi
plot(phi_marginal, type = "l",
     xlab = expression(phi),
     ylab = "Densidad",
     main = "Distribución posterior de phi (proporción estructurada)")

# Obtener resumen estadístico
phi_summary <- inla.zmarginal(phi_marginal)
print(phi_summary)

```

###COMPARAR MODELOS CON DIFERENTES EFECTOS ESPACIALES

```{r}

# Fórmula base (sin efecto espacial)
formula_base <- egresos_total ~ 1 + PobR_s + nocontrol_s + Obe_s + cobertura_s +
  f(time_id, model = "ar1")

# Lista de modelos espaciales
modelos <- list(
  BYM2 = update(formula_base, . ~ . + 
    f(area_id, replicate = time_id, model = "bym2", graph = inla_graph,
      scale.model = TRUE, constr = TRUE,
      hyper = list(
        phi = list(prior = "pc", param = c(0.5, 0.75)),
        prec = list(prior = "pc.prec", param = c(0.5, 0.01))
      ))),
  
  IID = update(formula_base, . ~ . + f(area_id, model = "iid")),
  
  Besag = update(formula_base, . ~ . + f(area_id, model = "besag", graph = inla_graph)),
  
  SinEspacial = formula_base
)

# Ajustar modelos y guardar resultados
resultados <- lapply(modelos, function(f) {
  inla(f,
       family = "poisson",
       data = baseFinal,
       E = baseFinal$esperados,
       control.fixed = list(correlation.matrix = TRUE, prec.intercept = 1, prec = 1),
       control.compute = list(dic = TRUE, waic = TRUE, cpo = TRUE))
})

# Extraer métricas de comparación
comparacion <- data.frame(
  Modelo = names(resultados),
  DIC = sapply(resultados, function(x) x$dic$dic),
  WAIC = sapply(resultados, function(x) x$waic$waic),
  CPO = sapply(resultados, function(x) -sum(log(x$cpo$cpo), na.rm = TRUE))  # log-score total
)

print(comparacion)
```

##Agregar el riesgo relativo a la base original 
```{r}
baseFinal$RR <- mod_final$summary.fitted.values[, "mean"]
baseFinal$L_i <- mod_final$summary.fitted.values[, "0.025quant"]
baseFinal$L_s <- mod_final$summary.fitted.values[, "0.975quant"]
```
 
##Agregar el RR al shapefile para crear los mapas 
```{r}
###EXTRAER EL RR DEL MODELO PARA AGREGARLO AL SHP Y MAPEAR 

shp1 <- left_join(shp1, 
                  baseFinal %>% select(UP, Año, RR, L_i, L_s),
                  by = c("UP", "Año"))
```

```{r}

# 1. Crear la nueva variable categórica del riesgo relativo según según el valor si es mayor o menor a 1
shp1$RR_Categoria <- cut(round(shp1$RR,1),
                         breaks = c(-Inf, 0.9, 1.5, Inf),
                         labels = c("Bajo", "Medio", "Alto"),
                         right = TRUE)

# 2. Reordenar los niveles para una leyenda lógica 
shp1$RR_Categoria <- factor(shp1$RR_Categoria, levels = c("Bajo", "Medio", "Alto"))

```

##Mapa de riesgo según categoría
```{r}
# 3. Generar el mapa con la nueva variable 
map1 <- ggplot(shp1) +
    geom_sf(aes(fill = RR_Categoria)) + # Usar la nueva variable categórica
    facet_wrap(~Año, dir = "h", ncol = 3) +
    ggtitle("Riesgo relativo por área de salud y año") +
    theme_bw() +
    theme(
        axis.text.x = element_blank(),
        axis.text.y = element_blank(),
        axis.ticks = element_blank(),
        # MODIFICACIONES AÑADIDAS:
        plot.title = element_text(hjust = 0.5), # Centra el título principal
        legend.title = element_text(hjust = 0.5) # Centra el título de la leyenda
    ) +
    scale_fill_manual(
        name = "Riesgo Relativo",
        values = c("Bajo" = "green", "Medio" = "orange", "Alto" = "red"),
        na.value = "gray50" # Color para valores faltantes (NA)
    )
#Guardar el gráfico 
ggsave(
    filename = "mapa_riesgo_relativo.png", # Nombre del archivo
    plot = map1,                        # El objeto de gráfico que creaste
    width = 14,                            # Ancho en pulgadas (ajusta según necesites)
    height = 6,                            # Alto en pulgadas (ajusta según necesites)
    dpi = 300                              # Resolución (300 DPI es el estándar de publicación)
)
```



#TABLAS DE RESUMEN DE PARAMETROS
```{r}

# -----------------------------
# Efectos fijos (covariables)
# -----------------------------
fixed <- mod_final$summary.fixed

# Renombrar variables con los nombres para la tabla 
fixed_tab <- data.frame(
  Variable = c("Intercepto", "Población Rural", "No control", "Obesidad", "Cobertura"), 
  Media = round(fixed[, "mean"],2),
  sd = round(fixed[, "sd"],2),
  Li = round(fixed[, "0.025quant"],2),
  Ls = round(fixed[, "0.975quant"],2)
  
)

# Crear tabla flextable
ft_fixed <- flextable(fixed_tab) %>%
  set_header_labels(
    Variable = "Variable",
    Media = "Media",
    sd = "sd",
    Li = "2.5%",
    Ls = "97.5%"
  ) %>%
  autofit()

# -----------------------------
#  Hiperparámetros de los efectos espaciales y temporales 
# -----------------------------
hyper <- mod_final$summary.hyperpar


# Renombrar hiperparámetros con letras griegas
hyper_tab <- data.frame(
  Parámetro = c(
    "τ_área (Precisión área)", 
    "φ (Proporción estructural espacial)", 
    "τ_tiempo (Precisión tiempo)",
    "ρ_tiempo (Dependencia temporal)"
  ),
  Media = round(hyper[, "mean"],2),
  sd = round(hyper[, "sd"], 2),
  Li = round(hyper[, "0.025quant"], 2),
  Ls = round(hyper[, "0.975quant"], 2)
)

library(flextable)
ft_hyper <- flextable(hyper_tab) %>%
  set_header_labels(
    Parámetro = "Hiperparámetro",
    Media = "Media",
    SD = "sd",
    Li = "2.5%",
    Ls = "97.5%"
  ) %>%
  autofit()

# -----------------------------
#  Criterios de ajuste
# -----------------------------
# Extraer criterios
criterios_tab <- data.frame(
  Criterio = c("DIC", "WAIC", "logCPO"),
  Valor = round(c(mod_final$dic$dic, mod_final$waic$waic, -sum(log(mod_final$cpo$cpo),0))  # logCPO total
))

ft_criterios <- flextable(criterios_tab) %>%
  set_header_labels(
    Criterio = "Criterio",
    Valor = "Valor"
  ) %>%
  autofit()

# -----------------------------
#  Mostrar tablas 
# -----------------------------
ft_fixed
ft_hyper
ft_criterios

```


##Cálculo del cambio porcentual del los coeficientes de las covariables 
```{r}
# 1. Definir el vector de coeficientes para obtener el 
coeficientes <- c(
    Interc = -0.10,
    PobR_s = 0.16,
    nocontrol_s = 0.13,
    Obe_s = 0.07,
    cobertura_s = 0.15
)

# 2. Calcular el Cambio Porcentual usando la función exponencial
cambio_porcentual <- round((exp(coeficientes) - 1) * 100,0)

# 3. Crear una tabla de resultados
resultados_porcentuales <- data.frame(
    Coeficiente = names(coeficientes),
    Estimacion_Log_RR = coeficientes,
    Cambio_Porcentual = cambio_porcentual
)

# 4. Mostrar la tabla
print(resultados_porcentuales)
```

